const { argv } = require('yargs');
const chalk = require('chalk');
const del = require('del');
const fs = require('fs');
const { src, dest, task, series, parallel } = require('gulp');
const path = require('path');
const pkg = require('./package.json');
const pug = require('gulp-pug');
const webpack = require('webpack');
const webpackConfig = require('./webpack.config.js');

//- gulp --production | -p initiates webpack's production version (no source maps, minified JS)
const production = !!argv.production || !!argv.p;

/**
 * Compile TypeScript with Webpack
 * @param {function} done (callback) 
 */
function js(done) {

  // copy version number from package.json to code: version.ts
  const s = `// --- This file is automatically generated ---\nexport default "${pkg.version}";\n`;
  fs.writeFileSync(path.resolve(process.cwd(), 'src', 'version.ts'), s, 'utf8');

  // set webpack mode
  if (production) {
    webpackConfig.mode = 'production';
    console.log(chalk.inverse.cyan('--- Production version in progress ---'));
  } else {
    webpackConfig.mode = 'development';
  }

  webpack(webpackConfig, function (err, stats) {
    if (err) throw new Error('webpack error', err);
    console.log('[webpack]', stats.toString({}));
    done();
  });

};

/**
 * Generate Pug Templates
 */
function templates() {
  global.pkgVersion = pkg.version;
  return src(['./src/jade/*.pug', './test/testpage*.pug'])
    .pipe(pug({
      doctype: 'html',
      globals: ['pkgVersion'],
      verbose: true
    }))
    .pipe(dest('./dist/'))
};

const copy = () => {
  const targetDir = 'D:/Dokumente/GitHub/blog/static/js';
  return src(['./dist/videoload2.js']).pipe(dest(targetDir));
}

task('clean', () => del(['dist']));
task('copy', copy);
const generate = parallel(templates, js);
task('default', series('clean', generate, 'copy'));